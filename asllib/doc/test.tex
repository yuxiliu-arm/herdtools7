\documentclass{book}
\input{ASLmacros}
% \renewcommand\color[1]{}
\renewcommand\xlongrightarrow[1]{\xrightarrow{\qquad#1\qquad}}

% inferrule override
\newenvironment{mathpar}{\begin{displaymath}\begin{prooftree}}{\end{prooftree}\end{displaymath}}
\renewcommand\inferrule[3][]{\AxiomC{$\displaylines{#2}$}\LeftLabel{#1}\UnaryInfC{$\displaylines{#3}$}}

% \renewcommand\and[0]{\end{prooftree}\end{displaymath}\begin{displaymath}\begin{prooftree}}
% \renewcommand\hyperlink[2]{#2}
% \renewcommand\hypertarget[2]{#2}

\newcommand{\definitiontests}{../tests/ASLDefinition.t/}
\newcommand{\syntaxtests}{../tests/ASLSyntaxReference.t/}
\newcommand{\typingtests}{../tests/ASLTypingReference.t/}
\newcommand{\semanticstests}{../tests/ASLSemanticsReference.t/}
\renewcommand\nameref[1]{\ref{#1}}

% fix MathJax \textbackslash only available in text mode
\renewcommand\textbackslash[0]{\unicode{x5C}}

\begin{document}

% \section{Example Specification 1}
% \figref{spec1} shows

% \begin{center}
% \lstinputlisting[caption=Example specification 1\label{fi:spec1}]{\definitiontests/spec1.asl}
% \end{center}

% % inferrule example
% \begin{mathpar}
% \inferrule[other]{
%   \visone \neq \Top \vistwo \neq \Top \astlabel(\visone) \neq \astlabel(\vistwo)
% }{
%   \symintsetsubset(\tenv, \visone, \vistwo) \typearrow \overname{\False}{\vb}
% }
% \end{mathpar}

% % inferrule with `\and` inside an `inferrule`
% \begin{mathpar}
%   \inferrule{P_1 \and \ldots \and P_k}{C}
% \end{mathpar}

% % multiple inferrule separated by `\and`
% \begin{mathpar}
% \inferrule[empty]{}{ \addpolynomials(\emptylist) \typearrow \emptyfunc }
% \and
% \inferrule[one]{}{ \addpolynomials([ \vp ]) \typearrow \vp }
% \end{mathpar}

% \begin{mathpar}
%   \inferrule[WriteToBitvector.Empty]{}
%   {
%     \writetobitvector(\emptylist, \nvbitvector(\emptylist), \nvbitvector(\emptylist)) \evalarrow \nvbitvector(\emptylist)
%   }
%   \and
%   \inferrule[WriteToBitvector.NonEmpty]{
%     \vs_n \ldots \vs_1 \eqdef \asbitvector(\src)\\
%     \vd_n \ldots \vd_1 \eqdef \asbitvector(\dst)\\
%     \slicestopositions(n, \slices) \evalarrow \positions \OrDynError\\\\
%     {\mathit{bit} = \lambda i \in 1..n.\left\{ \begin{array}{ll}
%      \vs_i & i \in \positions\\
%      \vd_i & \text{otherwise}
%     \end{array} \right\}\\
%     \vv\eqdef\nvbitvector(\mathit{bit}(n-1)\ldots \mathit{bit}(0))\\
%   }}
%   {
%     \writetobitvector(\slices, \src, \dst) \evalarrow \vv
%   }
% \end{mathpar}

% \begin{prooftree}
%   \AxiomC{$
%     \texttt{s}_n \ldots \texttt{s}_1
% \href{#def-eqdef}{:=}\href{#def-asbitvector}{\textit{as\_bitvector}}(\texttt{src})\\
%     \texttt{d}_n \ldots \texttt{d}_1
% \href{#def-eqdef}{:=}\href{#def-asbitvector}{\textit{as\_bitvector}}(\texttt{dst})\\
%     \href{#def-slicestopositions}{\textit{slices\_to\_positions}}(n,
% \texttt{slices})
% \xrightarrow{\href{#def-evalrel}{\textsf{eval}}}\texttt{positions}\;\href{#def-terminateas}{\mathbin{/\mkern-6mu/}}\;\href{#def-errorconfig}{\texttt{\#DE}}\\\\
%     {\mathit{bit} = \lambda i \in 1..n.\left\{ \begin{array}{ll}
%      \texttt{s}_i & i \in \texttt{positions}\\
%      \texttt{d}_i & \text{otherwise}
%     \end{array} \right.}\\
%     \texttt{v}\href{#def-eqdef}{:=}\href{#def-nvbitvector}{\texttt{Bitvector}}(\mathit{bit}(n-1)\ldots
% \mathit{bit}(0))\\
%   }$\LeftLabel{WriteToBitvector.NonEmpty}\UnaryInfC{$
%     \href{#def-writetobitvector}{\textit{write\_to\_bitvector}}(\texttt{slices},
% \texttt{src}, \texttt{dst})
% \xrightarrow{\href{#def-evalrel}{\textsf{eval}}}\texttt{v}
%   $}
% \end{prooftree}
% \hypertarget{def-triangleq}{}
% We use $\triangleq$

% \[
%  A \triangleq B
% \]

% For a set of Boolean values $A$:
% \[
%   \begin{array}{rcl}
%   \land A &\triangleq&
%   \begin{cases}
%     \True & \text{if all values in A are }\True\\
%     \False & \text{otherwise}
%   \end{cases}\\
%   \lor A &\triangleq&
%   \begin{cases}
%     \False & \text{if all values in A are }\False\\
%     \True & \text{otherwise}
%   \end{cases}\\
% \end{array}
% \]

% \hypertarget{def-rebitmasklit}{}
% \begin{center}
% \begin{tabular}{rcl}
% $\REbitmasklit$ &$\triangleq$& \anycharacter{\texttt{'}} (\anycharacter{\texttt{01x}\square})* \anycharacter{\texttt{'}}
% \end{tabular}
% \end{center}

% \hypertarget{def-nstmt}{}
% \begin{flalign*}
% \Nstmt \derivesinline\ & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nstmtlist \parsesep \Nselse \parsesep \Tend \parsesep \Tsemicolon &\\
% |\ & \Tcase \parsesep \Nexpr \parsesep \Tof \parsesep \Ncasealtlist \parsesep \Tend \parsesep \Tsemicolon &\\
% |\ & \Twhile \parsesep \Nexpr \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
% |\ & \Tlooplimit \parsesep \Tlpar \parsesep \Nexpr \parsesep \Trpar \parsesep \Twhile \parsesep \Nexpr \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
% |\ & \Tfor \parsesep \Tidentifier \parsesep \Teq \parsesep \Nexpr \parsesep \Ndirection \parsesep
%                     \Nexpr \parsesep \Tdo \parsesep \Nstmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
% |\ & \Ttry \parsesep \Nstmtlist \parsesep \Tcatch \parsesep \nonemptylist{\Ncatcher} \parsesep \Notherwiseopt \parsesep \Tend \parsesep \Tsemicolon &\\
% |\ & \Tpass \parsesep \Tsemicolon &\\
% |\ & \Treturn \parsesep \option{\Nexpr} \parsesep \Tsemicolon &\\
% |\ & \Tidentifier \parsesep \Plist{\Nexpr} \parsesep \Tsemicolon &\\
% |\ & \Tassert \parsesep \Nexpr \parsesep \Tsemicolon &\\
% |\ & \Nlocaldeclkeyword \parsesep \Ndeclitem \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
% |\ & \Nlexpr \parsesep \Teq \parsesep \Nexpr \parsesep \Tsemicolon &\\
% |\ & \Tidentifier \parsesep \Plist{\Nexpr} \parsesep \Teq \parsesep \Nexpr &\\
% |\ & \Tidentifier \parsesep \Plist{\Nexpr} \parsesep \Tdot \parsesep \Tidentifier \parsesep \Teq \parsesep \Nexpr &\\
% |\ & \Tidentifier \parsesep \Plist{\Nexpr} \parsesep \Tdot \parsesep \Tlbracket \parsesep \Clisttwo{{\Tidentifier}} \parsesep \Trbracket \parsesep \Teq \parsesep \Nexpr &\\
% |\ & \Tvar \parsesep \Ndeclitem \parsesep \option{\Teq \parsesep \Nexpr} \parsesep \Tsemicolon &\\
% |\ & \Tvar \parsesep \Clisttwo{\Tidentifier} \parsesep \Tcolon \parsesep \Nty \parsesep \Tsemicolon &\\
% |\ & \Tprint \parsesep \Plist{\Nexpr} \parsesep \Tsemicolon &\\
% |\ & \Tunreachable \parsesep \Tlpar \parsesep \Trpar \parsesep \Tsemicolon &\\
% |\ & \Trepeat \parsesep \Nstmtlist \parsesep \Tuntil \parsesep \Nexpr \parsesep \Tsemicolon &\\
% |\ & \Tlooplimit \parsesep \Tlpar \parsesep \Nexpr \parsesep \Trpar \parsesep \Trepeat \parsesep \Nstmtlist \parsesep \Tuntil \parsesep \Nexpr \parsesep \Tsemicolon &\\
% |\ & \Tthrow \parsesep \Nexpr \parsesep \Tsemicolon &\\
% |\ & \Tthrow \parsesep \Tsemicolon &\\
% |\ & \Tpragma \parsesep \Tidentifier \parsesep \Clist{\Nexpr} \parsesep \Tsemicolon &
% \end{flalign*}

% relation $\evalexprsef$

% \begin{center}
% \begin{tabular}{lll}
% \hline
% \secreflink{IntegerTypesSyntax} & \secreflink{IntegerTypesAST} & \secreflink{TypingIntegerTypes}\\
% & \secreflink{ASTRule.Ty.TInt} & \secreflink{TypingRule.TInt}\\
% & \secreflink{ASTRule.IntConstraintsOpt} & \secreflink{TypingRule.AnnotateConstraint}\\
% & \secreflink{ASTRule.IntConstraints} & \\
% & \secreflink{ASTRule.IntConstraint} &\\
% \hline
% \end{tabular}
% \end{center}

% \[
%   \texttt{\textbackslash\;\;n}
% \]

% \[

%     {\mathit{bit} = \lambda i \in 1..n.\left\{ \begin{array}{ll}
%      \vs_i & i \in \positions\\
%      \vd_i & \text{otherwise}
%     \end{array} \right.}
% \]

\begin{flalign*}
  % & & \ASTComment{Constraints that may be assigned to integer types.}  \\
  \constraintkind \derives\ & \unconstrained
\end{flalign*}

\end{document}
