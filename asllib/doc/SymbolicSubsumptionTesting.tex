\chapter{Symbolic Subsumption Testing\label{chap:SymbolicSubsumptionTesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter is concerned with implementing a \hyperlink{def-soundsubsumptiontest}{sound subsumption test}
for integer types, as defined in \secref{subsumptiontesting} and employed by
TypingRule.SubtypeSatisfaction (see \secref{TypingRule.SubtypeSatisfaction}).

\hypertarget{def-symbolicdomain}{}
The symbolic reasoning operates by first transforming types into expressions in a \emph{symbolic domain} AST
(defined next, reusing $\intconstraint$ from the untyped AST) over which it then operates:
\hypertarget{def-symdom}{}
\hypertarget{def-finite}{}
\[
  \begin{array}{rcl}
    \symdom &::=& \Finite(\powfin{\Z} \setminus \emptyset) \hypertarget{def-top}{}\\
            &|  & \Top                      \hypertarget{def-fromsymtax}{}\\
            &|  & \FromSyntax(\syntax)      \hypertarget{def-syntax}{}\\
    \syntax &::=& \intconstraint^*
  \end{array}
\]

\begin{itemize}
  \item We refer to an element of the form $\Finite(S)$ as a \emph{symbolic finite set integer domain},
        which represents the set of integers $S$;
  \item We refer to an element of the form $\FromSyntax(\vcs)$ as a \emph{symbolic constrained integer domain},
        which represents the set of integers given by the list of constraints $\vcs$; and
  \item We refer to an element of the form $\Top$ as a \emph{symbolic unconstrained integer domain},
        which represents the set of all integers.
\end{itemize}

The main rule is of this chapter is TypingRule.SymSubsumes (see \secref{TypingRule.SymSubsumes}), which defines the function
$\symsubsumes$.

Other helper rules are as follows:
\begin{itemize}
  \item TypingRule.SymDomOfType (see \secref{TypingRule.SymDomOfType})
  \item TypingRule.SymDomOfExpr (see \secref{TypingRule.SymDomOfExpr})
  \item TypingRule.SymDomOfWidth (see \secref{TypingRule.SymDomOfWidth})
  \item TypingRule.IntSetOp (see \secref{TypingRule.IntSetOp})
  \item TypingRule.IntSetToIntConstraints (see \secref{TypingRule.IntSetToIntConstraints})
  \item TypingRule.SymDomOfLiteral (see \secref{TypingRule.SymDomOfLiteral})
  \item TypingRule.SymIntSetOfConstraints (see \secref{TypingRule.SymIntSetOfConstraints})
  \item TypingRule.ConstraintToIntSet (see \secref{TypingRule.ConstraintToIntSet})
  \item TypingRule.NormalizeToInt (see \secref{TypingRule.NormalizeToInt})
  \item TypingRule.SymDomIsSubset (see \secref{TypingRule.SymDomIsSubset})
  \item TypingRule.SymIntSetSubset (see \secref{TypingRule.SymIntSetSubset})
  \item TypingRule.ConstraintBinop (see \secref{TypingRule.ConstraintBinop})
\end{itemize}

\subsubsection{TypingRule.SymSubsumes \label{sec:TypingRule.SymSubsumes}}
\hypertarget{def-symsubsumes}{}
The predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb}
\]
soundly approximates $\subsumes(\tenv, \vt, \vs)$ for integer types.
\ProseOtherwiseTypeError

We assume that both $\vt$ and $\vs$ have been successfully annotated to integer types as per \chapref{Types}
(otherwise a typing error prevents us from applying this function).

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\symdomoftype$ to $\vt$ in $\tenv$ yields $\dt$;
  \item applying $\symdomoftype$ to $\vs$ in $\tenv$ yields $\ds$;
  \item applying $\symdomissubset$ to $\dt$ and $\ds$ in $\tenv$ yields $\vb$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{
  \symdomoftype(\tenv, \vt) \typearrow \dt\\
  \symdomoftype(\tenv, \vs) \typearrow \ds\\
  \symdomissubset(\tenv, \dt, \ds) \typearrow \vb
}{
  \symsubsumes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\subsubsection{TypingRule.SymDomOfType \label{sec:TypingRule.SymDomOfType}}
\hypertarget{def-symdomoftype}{}
The function
\[
  \symdomoftype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \overname{\symdom}{\vd}
\]
transforms a type $\vt$ in a static environment $\tenv$ into a symbolic domain $\vd$.
It assumes its input type has an \underlyingtype{} which is an integer.
\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{int\_unconstrained}):
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type;
    \item define $\vd$ as $\Top$, which intuitively represents the entire set of integers.
  \end{itemize}

  \item All of the following apply (\textsc{int\_parameterized}):
  \begin{itemize}
    \item $\vt$ is the \parameterizedintegertype\ for the identifier $\id$;
    \item define $\vd$ as the symbolic constrained integer domain with a single constraint for the variable expression for $\id$,
          that is, \\ $\FromSyntax([\ConstraintExact(\EVar(\id))])$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_well\_constrained\_finite}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\intsetofintconstraints$ to $\vcs$ in $\tenv$ yields $\vis$;
    \item $\vis$ is a set of integers, that is, $\astlabel(\vis)$ is $\Finite$;
    \item define $\vd$ as the symbolic finite set integer domain for $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_well\_constrained\_symbolic}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\intsetofintconstraints$ to $\vcs$ in $\tenv$ yields $\vis$;
    \item $\vis$ is not a set of integers, that is, $\astlabel(\vis)$ is not $\Finite$;
    \item define $\vd$ as the symbolic constrained integer domain for the list of constraints $\vcs$, that is, $\FromSyntax(\vcs)$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_named}):
  \begin{itemize}
    \item $\vt$ is the named type for identifier $\id$;
    \item applying $\makeanonymous$ to $\vt$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ in $\tenv$ yields $\vd$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[int\_unconstrained]{}{ \symdomoftype(\tenv, \overname{\unconstrainedinteger}{\vt}) \typearrow \overname{\Top}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[int\_parameterized]{}{
  \symdomoftype(\tenv, \overname{\TInt(\parameterized(\id))}{\vt}) \typearrow \\
  \overname{\FromSyntax([\ConstraintExact(\EVar(\id))])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained\_finite]{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \vis\\
  \astlabel(\vis) = \Finite
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\vis}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained\_symbolic]{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \vis\\
  \astlabel(\vis) \neq \Finite
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\FromSyntax(\vcs)}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  \vt = \TNamed(\id)\\
  \makeanonymous(\vt) \typearrow \vtone\\
  \symdomoftype(\tenv, \vtone) \typearrow \vd
}{
  \symdomoftype(\tenv, \vt) \typearrow \vd
}
\end{mathpar}

\subsubsection{TypingRule.SymDomOfExpr \label{sec:TypingRule.SymDomOfExpr}}
\hypertarget{def-symdomofexpr}{}
The function
\[
\symdomofexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto
\overname{\symdom}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$ in the static environment $\tenv$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\ve$ is a literal expression for the literal $\vv$;
    \item applying $\symdomofliteral$ to $\vv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_constant}):
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vx$;
    \item applying $\lookupconstant$ to $\vx$ in $\tenv$ yields the literal $\vv$;
    \item applying $\symdomofliteral$ to $\vv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var\_type}):
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vx$;
    \item applying $\lookupconstant$ to $\vx$ in $\tenv$ yields $\bot$;
    \item applying $\typeof$ to $\vx$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop\_minus}):
  \begin{itemize}
    \item $\ve$ is a unary operation expression for the operation $\MINUS$ and subexpression $\veone$;
    \item applying $\symdomofexpr$ to the binary operation expression with the operation $\MINUS$
          and the literal expression for $0$ and $\veone$ in $\tenv$ yields $\vd$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop\_unknown}):
  \begin{itemize}
    \item $\ve$ is a unary operation expression for an operation that is not $\MINUS$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop\_supported}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression for an operation that is one of $\PLUS$, $\MINUS$, or $\MUL$
          and subexpressions $\veone$ and $\vetwo$;
    \item applying $\symdomofexpr$ to $\veone$ in $\tenv$ yields a symbolic domain $\visone$;
    \item applying $\symdomofexpr$ to $\vetwo$ in $\tenv$ yields a symbolic domain $\vistwo$;
    \item applying $\intsetop$ to $\op$ and $\visone$ and $\vistwo$ yields $\vis$;
    \item define $\vd$ as $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop\_unsupported}):
  \begin{itemize}
    \item $\ve$ is a binary operation expression for an operation that is not one of $\PLUS$, $\MINUS$, or $\MUL$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}

  \item All of the following apply (\textsc{unsupported}):
  \begin{itemize}
    \item $\ve$ is not one of the following expression types a literal expression, a variable expression, a unary operation
          expression, or a binary operation expression;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[e\_literal]{
  \symdomofliteral(\vv) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\ELiteral(\vv)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_constant]{
  \lookupconstant(\tenv, \vx) \typearrow \vv\\
  \symdomofliteral(\vv) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_type]{
  \lookupconstant(\tenv, \vx) \typearrow \bot\\
  \typeof(\tenv, \vx) \typearrow \vtone\\
  \symdomoftype(\vtone) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop\_minus]{
  \symdomofexpr(\EBinop(\MINUS, \ELiteral(\lint(0)), \veone)) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EUnop(\MINUS, \veone)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop\_unknown]{
  \op \neq \MINUS
}{
  \symdomofexpr(\tenv, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop\_supported]{
  \op \in \{\PLUS, \MINUS, \MUL\}\\
  \symdomofexpr(\tenv, \veone) \typearrow \visone\\
  \symdomofexpr(\tenv, \vetwo) \typearrow \vistwo\\
  \intsetop(\op, \visone, \vistwo) \typearrow \vis
}{
  \symdomofexpr(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\vis}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop\_unsupported]{
  \op \not\in \{\PLUS, \MINUS, \MUL\}\\
}{
  \symdomofexpr(\tenv, \overname{\EBinop(\op, \Ignore, \Ignore)}{\ve}) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unsupported]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EUnop, \EBinop\}
}{
  \symdomofexpr(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\subsubsection{TypingRule.SymDomOfWidth \label{sec:TypingRule.SymDomOfWidth}}
\hypertarget{def-symdomofwidth}{}
The function
\[
\symdomofwidth(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto
\overname{\symdom}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$ in the static environment $\tenv$.
In contrast to $\symdomofexpr$, $\symdomofwidth$ should be applied to expressions that represent a bit vector width.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{finite\_one\_width}):
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is a set of integers, that is, $\Finite(s)$;
    \item the cardinality of $s$ is one;
    \item $\vd$ is $\vdone$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_multiple\_widths}):
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is a set of integers, that is, $\Finite(s)$;
    \item the cardinality of $s$ is \emph{not} one;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_finite}):
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is not a set of integers, that is, $\astlabel(\vdone)$ is not $\Finite$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[finite\_one\_width]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \vdone = \Finite(s) \\
  \cardinality{s} = 1
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\vdone}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_multiple\_widths]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \vdone = \Finite(s) \\
  \cardinality{s} \neq 1
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_finite]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \astlabel(\vdone) \neq \Finite
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\subsubsection{TypingRule.IntSetOp \label{sec:TypingRule.IntSetOp}}
\hypertarget{def-intsetop}{}
The function
\[
\intsetop(\overname{\binop}{\op} \aslsep \overname{\symdom}{\visone} \aslsep \overname{\symdom}{\vistwo})
\aslto \overname{\symdom}{\vis}
\]
applies the binary operation $\op$ to the symbolic domains $\visone$ and $\vistwo$,
yielding the symbolic domain $\vis$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{top}):
  \begin{itemize}
    \item at least one of $\visone$ and $\vistwo$ is $\Top$;
    \item define $\vis$ as $\Top$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_finite}):
  \begin{itemize}
    \item $\visone$ is the symbolic finite set integer domain for $\vsone$;
    \item $\vistwo$ is the symbolic finite set integer domain for $\vstwo$;
    \item define $\vis$ as the symbolic finite set domain for the set obtained
          by applying $\op$ to each element of $\vsone$ and each element of $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{finite\_syntax}):
  \begin{itemize}
    \item $\visone$ is the symbolic finite set integer domain for $\vsone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\vstwo$;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item applying $\intsetop$ to $\op$, the symbolic constrained integer domain for $\csone$,
          and $\vistwo$ yields $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_finite}):
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic finite set integer domain for $\vstwo$;
    \item applying $\intsettointconstraints$ to $\vstwo$ yields the list of constraints $\cstwo$;
    \item applying $\intsetop$ to $\op$, $\visone$, and the symbolic constrained integer domain
          for $\cstwo$, yields $\vis$.
  \end{itemize}

  \item All of the following apply (\textsc{syntax\_syntax\_well\_constrained}):
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\cstwo$;
    \item applying $\constraintbinop$ to $\op$, $\csone$, and $\cstwo$ yields
          a list of constraints $\vcs$;
    \item define $\vis$ as the symbolic constrained integer domain for $\vcs$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[top]{
  \visone = \Top \lor \vistwo = \Top
}{
  \intsetop(\op, \visone, \vistwo) \typearrow \overname{\Top}{\vis}
}
\and
\inferrule[finite\_finite]{
  \vis \eqdef \Finite(\{ \op(a, b) \;|\; a \in \vsone, b \in \vstwo \})
}{
  \intsetop(\op, \overname{\Finite(\vsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_syntax]{
  \intsettointconstraints(\vsone) \typearrow \vcsone\\
  \intsetop(\op, \FromSyntax(\vcsone), \FromSyntax(\vcstwo)) \typearrow \vis
}{
  \intsetop(\op, \overname{\Finite(\vsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_finite]{
  \intsettointconstraints(\vstwo) \typearrow \vcstwo\\
  \intsetop(\op, \FromSyntax(\vcsone), \FromSyntax(\vcstwo)) \typearrow \vis
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_syntax\_well\_constrained]{
  \constraintbinop(\op, \vcsone, \vcstwo) \typearrow \wellconstrained(\vcs)
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \overname{\FromSyntax(\vcs)}{\vis}
}
\end{mathpar}

\subsubsection{TypingRule.IntSetToIntConstraints \label{sec:TypingRule.IntSetToIntConstraints}}
\hypertarget{def-intsettointconstraints}{}
The function
\[
\intsettointconstraints(\overname{\powfin{\Z}}{\vs})
\aslto \overname{\intconstraint^*}{\cs}
\]
transforms a finite set of integers into the equivalent list of integer constraints.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vs$ is the empty set;
    \item define $\cs$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{singleton}):
  \begin{itemize}
    \item $\vs$ is the singleton set for $a$;
    \item define $\cs$ as the list containing the single range constraint for the interval starting from $a$
          and ending at $a$, that is, $\ConstraintRange(\ELInt{a}, \ELInt{a})$.
  \end{itemize}

  \item All of the following apply (\textsc{new\_interval}):
  \begin{itemize}
    \item define $a$ as the minimal element of $\vs$;
    \item define $\vsone$ as the set $\vs$ with $a$ removed from it;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item $\csone$ is a list where its \head\ is a range constraint for the interval starting from $b$ and ending at $c$
          and \tail\ $\cstwo$;
    \item $b$ is greater than $a+1$;
    \item define $\cs$ as the list with first element a range constraint for the interval from $a$ to $a$,
          second element a range constraint for the interval from $b$ to $c$, and remaining elements given by $\cstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{merge\_interval}):
  \begin{itemize}
    \item define $a$ as the minimal element of $\vs$;
    \item define $\vsone$ as the set $\vs$ with $a$ removed from it;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item $\csone$ is a list where its \head\ is a range constraint for the interval starting from $b$ and ending at $c$
          and \tail\ $\cstwo$;
    \item $b$ is equal to $a+1$;
    \item define $\cs$ as the list with \head\  a range constraint for the interval from $a$ to $c$
          and \tail\ $\cstwo$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \intsettointconstraints(\overname{\emptyset}{\vs}) \typearrow \overname{\emptylist}{\cs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[singleton]{}{
  \intsettointconstraints(\overname{\{a\}}{\vs}) \typearrow \overname{[\ConstraintRange(\ELInt{a}, \ELInt{a})]}{\cs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[new\_interval]{
  a = \min(\vs)\\
  \vsone \eqdef \vs \setminus \{a\}\\
  \intsettointconstraints(\vsone) \typearrow \csone\\
  \csone = [\ConstraintRange(\ELInt{b}, \ELInt{c})] \concat \cstwo\\
  b > a + 1\\\\
  {
    \begin{array}{rcl}
  \cs  &\eqdef & [\ConstraintRange(\ELInt{a}, \ELInt{a})]\ \concat\\
        &       & [\ConstraintRange(\ELInt{b}, \ELInt{c})]\ \concat \\
        &       & \cstwo
    \end{array}
  }
}{
  \intsettointconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\begin{mathpar}
\inferrule[merge\_interval]{
  a = \min(\vs)\\
  \vsone \eqdef \vs \setminus \{a\}\\
  \intsettointconstraints(\vsone) \typearrow \csone\\
  \csone = [\ConstraintRange(\ELInt{b}, \ELInt{c})] \concat \cstwo\\
  b = a + 1\\
  \cs \eqdef [\ConstraintRange(\ELInt{a}, \ELInt{c})] \concat \cstwo
}{
  \intsettointconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\subsubsection{TypingRule.SymDomOfLiteral \label{sec:TypingRule.SymDomOfLiteral}}
\hypertarget{def-symdomofliteral}{}
The function
\[
\symdomofliteral(\overname{\literal}{\vv}) \typearrow \overname{\symdom}{\vd}
\]
returns the symbolic domain $\vd$ that corresponds to the literal $\vv$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\vv$ is an integer literal for $n$;
  \item define $\vd$ as the symbolic finite set integer domain for the singleton set for $n$, that is, $\Finite(\{n\})$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule{}{
  \symdomofliteral(\overname{\lint(n)}{\vv}) \typearrow \overname{\Finite(\{n\})}{\vd}
}
\end{mathpar}

\subsubsection{TypingRule.SymIntSetOfConstraints \label{sec:TypingRule.SymIntSetOfConstraints}}
\hypertarget{def-intsetofintconstraintse}{}
The function
\[
  \intsetofintconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\constraints}{\vcs}
  ) \aslto
  \overname{\symdom}{\vis}
\]
returns the symbolic domain $\vis$ for the list of constraints $\vcs$
in the static environment $\tenv$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{finite}):
  \begin{itemize}
    \item applying $\constrainttointset$ to every constraint $\vcs[\vi]$ in $\tenv$, for $\vi$ in \\ $\listrange(\vcs)$,
          yields a finite set of integers $C_\vi$, that is, $\Finite(C_\vi)$;
    \item define $\vis$ as the union of $C_\vi$ for all $\vi$ in $\listrange(\vcs)$.
  \end{itemize}

  \item All of the following apply (\textsc{symbolic}):
  \begin{itemize}
    \item there exists a constraint $\vc$ in $\vcs$ such that applying $\constrainttointset$ to $\vc$
          in $\tenv$ does not yield a finite set of integers;
    \item define $\vis$ as the symbolic constrained integer domain for $\vcs$, that is, \\
          $\FromSyntax(\vcs)$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[finite]{
  \vi\in\listrange(\vcs): \constrainttointset(\tenv, \vcs[\vi]) \typearrow \Finite(C_\vi)\\
  C \eqdef \bigcup_{\vi\in\listrange(\vcs)} C_\vi
}{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \overname{\Finite(C)}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[symbolic]{
  {
    \begin{array}{r}
  \exists \vi\in\listrange(\vcs): \constrainttointset(\tenv, \vcs[\vi]) \typearrow \\
     \visone \land \astlabel(\visone) \neq \Finite
    \end{array}
  }
}{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \overname{\FromSyntax(\vcs)}{\vis}
}
\end{mathpar}

\subsubsection{TypingRule.ConstraintToIntSet \label{sec:TypingRule.ConstraintToIntSet}}
\hypertarget{def-constrainttointset}{}
The function
\[
  \constrainttointset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\intconstraint}{\vc}
  ) \aslto
  \overname{\symdom}{\vis}
\]
transforms an integer constraint $\vc$ into a symbolic domain $\vis$.
It produces $\Top$ when the expressions involved in the integer constraints cannot be simplified
to integers.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is a single expression constraint for $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\normalizetoint$ to $\ve$ in $\tenv$ yields the integer $n$\ProseTerminateAs{\Top};
    \item define $\vis$ as the singleton set for $n$, that is, $\Finite(\{n\})$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is a range constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\normalizetoint$ to $\veone$ in $\tenv$ yields the integer $b$\ProseTerminateAs{\Top};
    \item applying $\normalizetoint$ to $\vetwo$ in $\tenv$ yields the integer $t$\ProseTerminateAs{\Top};
    \item define $\vis$ as the set integers that are both greater or equal to $b$ and less than or equal to $t$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[exact]{
  \normalizetoint(\tenv, \ve) \typearrow n \terminateas \Top
}{
  \constrainttointset(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\Finite(\{n\})}{\vis}
}
\and
\inferrule[range]{
  \normalizetoint(\tenv, \veone) \typearrow b \terminateas \Top\\\\
  \normalizetoint(\tenv, \vetwo) \typearrow t \terminateas \Top\\\\
  \vis \eqdef \Finite(\{ n \;|\; b \leq n \leq t\})
}{
  \constrainttointset(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vis
}
\end{mathpar}

\subsubsection{TypingRule.NormalizeToInt \label{sec:TypingRule.NormalizeToInt}}
\hypertarget{def-normalizetoint}{}
The function
\[
\normalizetoint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\Z}{n} \cup \{\Top\}
\]
\symbolicallysimplifies\ the \underline{integer-typed} expression $\ve$ and returns the resulting integer or $\Top$ if
the result of the simplification is not an integer.

We assume that $\ve$ has been annotated as it is part of the constraint for an integer type,
and therefore applying $\normalize$ to it does not yield a type error.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{integer}):
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the integer literal for $n$.
  \end{itemize}

  \item All of the following apply (\textsc{top}):
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields $\top$.
    \item the result is $\Top$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[integer]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \lint(n)
}{
  \normalizetoint(\tenv, \ve) \typearrow n
}
\and
\inferrule[top]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \top
}{
  \normalizetoint(\tenv, \ve) \typearrow \Top
}
\end{mathpar}

\subsubsection{TypingRule.SymDomIsSubset \label{sec:TypingRule.SymDomIsSubset}}
\hypertarget{def-symdomissubset}{}
The function
\[
  \symdomissubset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\symdom}{\vdone} \aslsep
    \overname{\symdom}{\vdtwo}
  ) \aslto
  \overname{\Bool}{\vb}
\]
conservatively tests whether the symbolic domain $\vdone$ is subsumed by the symbolic domain $\vdtwo$,
yielding the result $\vb$.

\subsubsection{Prose}
All of the following apply:
\begin{itemize}
  \item applying $\symintsetsubset$ to $\vdone$ and $\vdtwo$ in $\tenv$ yields $\vb$.
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[int]{
  \symintsetsubset(\tenv, \vdone, \vdtwo) \typearrow \vb
}{
  \symdomissubset(\tenv, \vdone, \vdtwo) \typearrow \vb
}
\end{mathpar}

\subsubsection{TypingRule.SymIntSetSubset \label{sec:TypingRule.SymIntSetSubset}}
\hypertarget{def-symintsetsubset}{}
The function
\[
\symintsetsubset(\overname{\staticenvs}{\tenv} \aslsep \overname{\symdom}{\visone} \aslsep \overname{\symdom}{\vistwo}) \aslto \overname{\Bool}{\vb}
\]

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{right\_top}):
  \begin{itemize}
    \item $\vistwo$ is $\Top$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item All of the following apply (\textsc{left\_top\_right\_not\_top}):
  \begin{itemize}
    \item $\visone$ is $\Top$;
    \item $\vistwo$ is not $\Top$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item All of the following apply (\textsc{finite}):
  \begin{itemize}
    \item $\visone$ is a finite set of integers for $\vsone$, that is, $\Finite(\vsone)$;
    \item $\vistwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item define $\vb$ as $\True$ if and only if $\vsone$ is a subset of $\vstwo$ or both sets are equal.
  \end{itemize}

  \item All of the following apply (\textsc{syntax}):
  \begin{itemize}
    \item $\visone$ is a set of integers given by the list of constraints $\csone$, that is, \\ $\FromSyntax(\vsone)$;
    \item $\vistwo$ is a set of integers given by the list of constraints $\cstwo$, that is, \\ $\FromSyntax(\vstwo)$;
    \item applying $\constraintsequal$ to $\csone$ and $\cstwo$ in $\tenv$ yields $\vb$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item both $\visone$ and $\vistwo$ are not $\Top$;
    \item the AST labels of $\visone$ and $\vistwo$ are different;
    \item define $\vb$ as $\False$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[right\_top]{}{
  \symintsetsubset(\tenv, \visone, \overname{\Top}{\vistwo}) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[left\_top\_right\_not\_top]{
  \vistwo \neq \Top
}{
  \symintsetsubset(\tenv, \overname{\Top}{\visone}, \vistwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite]{}{
  \symintsetsubset(\tenv, \overname{\Finite(\vsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax]{
  \constraintsequal(\tenv, \csone, \cstwo) \typearrow \vb
}{
  \symintsetsubset(\tenv, \overname{\FromSyntax(\csone)}{\visone}, \overname{\FromSyntax(\cstwo)}{\vistwo}) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \visone \neq \Top \and \vistwo \neq \Top\\
  \astlabel(\visone) \neq \astlabel(\vistwo)
}{
  \symintsetsubset(\tenv, \visone, \vistwo) \typearrow \overname{\False}{\vb}
}
\end{mathpar}

\subsubsection{TypingRule.ConstraintBinop\label{sec:TypingRule.ConstraintBinop}}
\hypertarget{def-constraintbinop}{}
The function
\[
\constraintbinop(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint^*}{\csone} \aslsep
  \overname{\intconstraint^*}{\cstwo}
)
\aslto \overname{\constraintkind}{\newcs}
\]
symbolically applies the binary operation $\op$ to the lists of integer constraints $\csone$ and $\cstwo$,
yielding the integer constraints $\vics$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{extremities}):
  \begin{itemize}
    \item $\op$ is either $\DIV$, $\DIVRM$, $\MUL$, $\PLUS$, $\MINUS$, $\SHR$, or $\SHL$;
    \item applying $\applybinopextremities$ to every pair of constraints $\csone[\vi]$ and $\cstwo[\vj]$
          where $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$, yields $\vc_{\vi,\vj}$;
    \item define $\newcs$ as the list of constraints $\vc_{\vi,\vj}$, for every
          $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$.
  \end{itemize}

  \item All of the following apply (\textsc{mod}):
  \begin{itemize}
    \item $\op$ is $\MOD$;
    \item applying $\constraintmod$ to $\cstwo[\vj]$, for every $\vj\in\listrange(\cstwo)$, yields $\vc_\vj$;
    \item define $\newcs$ as $\vc_\vj$, for every $\vj\in\listrange(\cstwo)$.
  \end{itemize}

  \item All of the following apply (\textsc{pow}):
  \begin{itemize}
    \item $\op$ is $\POW$;
    \item applying $\constraintpow$ to every pair of constraints $\csone[\vi]$ and $\cstwo[\vj]$
          where $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$, yields $\vc_{\vi,\vj}$;
    \item define $\newcs$ as the list of constraints $\vc_{\vi,\vj}$, for every
          $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[extremities]{
  \op \in \{\DIV, \DIVRM, \MUL, \PLUS, \MINUS, \SHR, \SHL\}\\
  {
    \begin{array}{r}
      \vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \\
      \applybinopextremities(\csone[\vi], \cstwo[\vj]) \typearrow \vc_{\vi,\vj}
    \end{array}
  }\\
  \newcs \eqdef [\vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \vc_{\vi,\vj}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[mod]{
  \op = \MOD\\
  \vj\in\listrange(\cstwo): \constraintmod(\cstwo[\vj]) \typearrow \vc_\vj\\
  \newcs = [\vj\in\listrange(\cstwo): \vc_\vj]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[pow]{
  \op = \POW\\
  {
    \begin{array}{r}
      \vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \\
      \constraintpow(\csone[\vi], \cstwo[\vj]) \typearrow \vc_{\vi,\vj}
    \end{array}
  }\\
  \newcs \eqdef [\vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \vc_{\vi,\vj}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}
\CodeSubsection{\ConstraintBinopBegin}{\ConstraintBinopEnd}{../Typing.ml}

\subsubsection{TypingRule.ApplyBinopExtremities\label{sec:TypingRule.ApplyBinopExtremities}}
\hypertarget{def-applybinopextremities}{}
The function
\[
\applybinopextremities(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vctwo}
) \aslto \overname{\intconstraint^*}{\newcs}
\]
yields a list of constraints $\newcs$ for the constraints $\vcone$ and $\vctwo$, which are needed to include
range constraints for cases where the binary operation $\op$ yields a dynamic error.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact\_exact}):
  \begin{itemize}
    \item $\vcone$ is a constraint for the expression $\va$;
    \item $\vctwo$ is a constraint for the expression $\vc$;
    \item define $\newcs$ as the list containing the constraint for the binary expression $\AbbrevEBinop{\op}{\va}{\vc}$.
  \end{itemize}

  \item All of the following apply (\textsc{range\_exact}):
  \begin{itemize}
    \item $\vcone$ is a range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is a constraint for the expression $\vc$;
    \item applying $\possibleextremitiesleft$ to $\op$, $\va$, and $\vb$ yields $\extpairs$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vc}}{\AbbrevEBinop{\op}{\vbp}{\vc}}$
          for each pair of expressions $(\vap, \vbp)$ in $\extpairs$.
  \end{itemize}

  \item All of the following apply (\textsc{exact\_range}):
  \begin{itemize}
    \item $\vcone$ is a constraint for the expression $\va$;
    \item $\vctwo$ is a range constraint for the expressions $\vc$ and $\vd$;
    \item applying $\possibleextremitiesright$ to $\op$, $\vc$, and $\vd$ yields $\extpairs$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\va}{\vcp}}{\AbbrevEBinop{\op}{\va}{\vdp}}$
          for each pair of expressions $(\vcp, \vdp)$ in $\extpairs$.
  \end{itemize}

  \item All of the following apply (\textsc{range\_range}):
  \begin{itemize}
    \item $\vcone$ is a range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is a range constraint for the expressions $\vc$ and $\vd$;
    \item applying $\possibleextremitiesright$ to $\op$, $\va$, and $\vb$ yields $\extpairsab$;
    \item applying $\possibleextremitiesright$ to $\op$, $\vc$, and $\vd$ yields $\extpairscd$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vcp}}{\AbbrevEBinop{\op}{\vbp}{\vdp}}$
          for each pair of expressions
          $(\vap, \vbp)$ in $\extpairsab$
          and each pair of expressions
          $(\vcp, \vdp)$ in $\extpairscd$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[exact\_exact]{}{
  {
    \begin{array}{r}
  \applybinopextremities(\op, \overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[ \ConstraintExact(\AbbrevEBinop{\op}{\va}{\vc}) ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \extpairs\\
  \newcs \eqdef [(\vap, \vbp) \in \extpairs: \AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vc}}{\AbbrevEBinop{\op}{\vbp}{\vc}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \extpairs\\
  \newcs \eqdef [(\vcp, \vdp) \in \extpairs: \AbbrevConstraintRange{\AbbrevEBinop{\op}{\va}{\vcp}}{\AbbrevEBinop{\op}{\va}{\vdp}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintRange(\vc, \vd)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \extpairsab\\
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \extpairscd\\
  \newcs \eqdef [(\vap, \vbp) \in \extpairsab, (\vcp, \vdp) \in \extpairscd:
  \AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vcp}}{\AbbrevEBinop{\op}{\vbp}{\vdp}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintRange(\vc, \vd)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\subsubsection{TypingRule.PossibleExtremitiesLeft\label{sec:TypingRule.PossibleExtremitiesLeft}}
\hypertarget{def-possibleextremitiesleft}{}
The function
\[
\possibleextremitiesleft(
  \overname{\binop}{\op} \aslsep
  \overname{\expr}{\va} \aslsep \overname{\expr}{\vb}
) \aslto \overname{(\expr\times\expr)^*}{\extpairs}
\]
yields a list of pairs of expressions $\extpairs$ given the binary operation $\op$
and pair of expressions $\va$ and $\vb$, which are needed to form constraints
for cases where applying $\op$ to $\va$ and $\vb$ would lead to a dynamic error.

\subsubsection{Prose}
\begin{itemize}
  \item All of the following apply (\textsc{mul}):
  \begin{itemize}
    \item $\op$ is $\MUL$;
    \item define $\extpairs$ as the list consisting of $(\va, \va)$, $(\va, \vb)$, $(\vb, \va)$, and $(\vb, \vb)$.
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\op$ is either $\DIV$, $\DIVRM$, $\SHR$, $\SHL$, $\PLUS$, or $\MINUS$;
    \item define $\extpairs$ as the list consisting of $(\va, \vb)$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[mul]{}{
  \possibleextremitiesleft(\overname{\MUL}{\op}, \va, \vb) \typearrow \overname{[(\va, \va), (\va, \vb), (\vb, \va), (\vb, \vb)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \op \in \{\DIV, \DIVRM, \SHR, \SHL, \PLUS, \MINUS\}
}{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \overname{[(\va, \vb)]}{\extpairs}
}
\end{mathpar}

\subsubsection{TypingRule.PossibleExtremitiesRight\label{sec:TypingRule.PossibleExtremitiesRight}}
\hypertarget{def-possibleextremitiesright}{}
The function
\[
\possibleextremitiesright(
  \overname{\binop}{\op} \aslsep
  \overname{\expr}{\vc} \aslsep \overname{\expr}{\vd}
) \aslto \overname{(\expr\times\expr)^*}{\extpairs}
\]
yields a list of pairs of expressions $\extpairs$ given the binary operation $\op$
and pair of expressions $\vc$ and $\vd$, which are needed to form constraints
for cases where applying $\op$ to $\vc$ and $\vd$ would lead to a dynamic error.

\subsubsection{Prose}
\begin{itemize}
  \item All of the following apply (\textsc{plus}):
  \begin{itemize}
    \item $\op$ is $\PLUS$;
    \item define $\extpairs$ as the list consisting of $(\vc, \vd)$.
  \end{itemize}

  \item All of the following apply (\textsc{minus}):
  \begin{itemize}
    \item $\op$ is $\MINUS$;
    \item define $\extpairs$ as the list consisting of $(\vd, \vc)$.
  \end{itemize}

  \item All of the following apply (\textsc{mul}):
  \begin{itemize}
    \item $\op$ is $\MUL$;
    \item define $\extpairs$ as the list consisting of $(\vc, \vc)$, $(\vc, \vd)$, $(\vd, \vc)$, and $(\vd, \vd)$.
  \end{itemize}

  \item All of the following apply (\textsc{shl\_shr}):
  \begin{itemize}
    \item $\op$ is either $\SHL$ or $\SHR$;
    \item define $\extpairs$ as the list consisting of $(\vd, \ELInt{0})$ and $(\ELInt{0}, \vd)$.
  \end{itemize}

  \item All of the following apply (\textsc{div\_divrm}):
  \begin{itemize}
    \item $\op$ is either $\DIV$ or $\DIVRM$;
    \item define $\extpairs$ as the list consisting of $(\vd, \ELInt{1})$ and $(\ELInt{1}, \vd)$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[plus]{}{
  \possibleextremitiesright(\overname{\PLUS}{\op}, \vc, \vd) \typearrow \overname{[(\vc, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[minus]{}{
  \possibleextremitiesright(\overname{\MINUS}{\op}, \vc, \vd) \typearrow \overname{[(\vd, \vc)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul]{}{
  \possibleextremitiesright(\overname{\MUL}{\op}, \vc, \vd) \typearrow \overname{[(\vc, \vc), (\vc, \vd), (\vd, \vc), (\vd, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shl\_shr]{
  \op \in \{\SHL, \SHR\}
}{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \overname{[(\vd, \ELInt{0}), (\ELInt{0}, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_divrm]{
  \op \in \{\DIV, \DIVRM\}
}{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \overname{[(\vd, \ELInt{1}), (\ELInt{1}, \vd)]}{\extpairs}
}
\end{mathpar}

\subsubsection{TypingRule.ConstraintMod\label{sec:TypingRule.ConstraintMod}}
\hypertarget{def-constraintmod}{}
The function
\[
\constraintmod(\overname{\intconstraint}{\vc}) \aslto \overname{\intconstraint}{\newc}
\]
yields a range constraint $\newc$ from $0$ to the expression in $\vc$ that is maximal.
This is needed to apply the modulus operation to a pair of constraints.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is a constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item $\newc$ is a constraint for the range from the literal expression for $0$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is a range constraint for some start expression and end expression $\ve$, that is, $\ConstraintRange(\Ignore, \ve)$;
    \item $\newc$ is a constraint for the range from the literal expression for $0$ to $\ve$.
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[exact]{}{
  \constraintmod(\overname{\ConstraintExact(\ve)}{\vc})
  \typearrow
  \overname{\ConstraintRange(\ELInt{0}, \ve)}{\newc}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{}{
  \constraintmod(\overname{\ConstraintRange(\Ignore, \ve)}{\vc})
  \typearrow
  \overname{\ConstraintRange(\ELInt{0}, \ve)}{\newc}
}
\end{mathpar}
\CodeSubsection{\ConstraintModBegin}{\ConstraintModEnd}{../Typing.ml}

\subsubsection{TypingRule.ConstraintPow\label{sec:TypingRule.ConstraintPow}}
\hypertarget{def-constraintpow}{}
The function
\[
\constraintpow(\overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vctwo}) \aslto \overname{\intconstraint^+}{\newcs}
\]
yields a list of range constraints $\newcs$ that are needed to calculate the result of
applying a $\POW$ operation to the constraints $\vcone$ and $\vctwo$.

\subsubsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact\_exact}):
  \begin{itemize}
    \item $\vcone$ is the constraint for the expression $\va$;
    \item $\vcone$ is the constraint for the expression $\vc$;
    \item define $\newcs$ as the list containing the constraint
    for the expression \\ $\EBinop(\POW, \va, \vc)$.
  \end{itemize}

  \item All of the following apply (\textsc{range\_exact}):
  \begin{itemize}
    \item $\vcone$ is the range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is the constraint for the expression $\vc$;
    \item define $\vmac$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vc)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \vb, \vc)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmac)$ and $\vmac$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}

  \item All of the following apply (\textsc{exact\_range}):
  \begin{itemize}
    \item $\vcone$ is the constraint for the expression $\va$;
    \item $\vctwo$ is the range constraint for the expressions $\Ignore$ and $\vd$;
    \item define $\vmad$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vd)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \va, \vd)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmad)$ and $\vmad$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}

  \item All of the following apply (\textsc{range\_range}):
  \begin{itemize}
    \item $\vcone$ is the range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is the range constraint for the expressions $\Ignore$ and $\vd$;
    \item define $\vmad$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vd)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \vb, \vd)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmad)$ and $\vmad$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Formally}
\begin{mathpar}
\inferrule[exact\_exact]{}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[\ \ConstraintExact(\EBinop(\POW, \va, \vc))\ ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \vmac \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vc)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\vb}{\vc}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmac)}{\vmac},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \vmad \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vd)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintRange(\Ignore, \vd)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\va}{\vd}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmad)}{\vmad},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \vmad \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vd)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintRange(\Ignore, \vd)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\vb}{\vd}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmad)}{\vmad},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\ConstraintPowBegin}{\ConstraintPowEnd}{../Typing.ml}
